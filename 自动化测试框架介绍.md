# 自动化测试是什么

一般是指**软件测试的自动化**，软件测试就是在预设条件下**运行系统或应用程序**，**评估**运行**结果**，预先条件应包括正常条件和异常条件。

自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。（From 百度百科）

# 为什么需要自动化测试

①、黑盒测试回归效率低

②、手动测试的偶然性和不确定性

③、回归的覆盖率不足

④、交付的产品质量无法保证，全靠评估

⑤、系统越复杂，问题越多

⑥、上线时间长、构件失败率高导致的蝴蝶效应。

简而言之，自动化测试代替手工测试，可以减少因为手工测试导致的偶然错误，可以调高测试效率，可以提高测试覆盖率。

# 自动化测试能解决什么样的问题

①、提高出现问题后的响应速率

②、降低回归成本

③、提高回归覆盖率

④、提高回归效率

⑤、提高回归的稳定性

自动化测试目前并不代表智能测试，并不能帮助我们自主地找出BUG，主要是提高我们在发现BUG之后定位效率以及回归测试的稳定性。

自动化测试主要目的，还是在于取代手工测试中一些重复的工作，例如：回归测试需要将之前的测试用例全部重新测试，自动化测试可以自动完成；测试中，需要编写测试报告，自动化测试可以在测试完成之后自动生成指定的测试报告；在测试中，测试用例不断增加，手工测试对于测试用例管理难度会不断增加，自动化测试可以帮助我们记忆测试用例以及拓展测试用例。

自动化测试并非完全只是代替机械重复的工作，而是可以在基于一定的基础，例如Junit，进行封装，完成一些相对简单的工作，减少测试的工作量。例如，自动扫描工程文件，生成相应结构的单元测试函数；通过制定约束条件，自动生成测试用例；通过简单的配置文件，对相对复杂的流程进行测试。

# 自动化测试的局限性

①、无法减少成本投入。

②、无法完全通用。

总体而言，自动化测试框架构建相对复杂，构建一个自动化测试化框架需要付出较大的时间、人力、物力成本。构建的自动化测试框架不一定具有通用性，具有通用性的框架难以具备指定的功能。但是，一个好的自动化测试框架，能够帮助我们节省大量时间，无论是测试用例的编写、还是测试用例的管理亦或是测试用例的编排，以及测试报告的生成，一个自动化测试框架都应该能够帮助或辅助我们快速完成。

# 自动化测试框架简介


## 自动化测试框架所具备的功能

> Log：日志记录和管理功能，针对不同的情况，设置不同的日志级别，方便定位问题；
>
> Report：测试报告生成和管理以及即时通知，测试结果快速响应；
>
> Source：配置文件、静态资源的管理，遵循高内聚低耦合原则；
>
> Common：公共函数、方法以及通用操作的管理，遵循高内聚低耦合原则；
>
> TestCase：测试用例管理功能，一个功能点对应一个或者多个case，尽可能的提高覆盖率；
>
> TestData：测试数据管理功能，数据与脚本分离，降低维护成本，提高可移植性；
>
> TestSuite：测试组件管理功能，针对不同场景不同需求，组装构建不同的测试框架，遵循框架的灵活性和扩展性；
>
> Statistics：测试结果统计管理功能，每次执行测试的结果统计、分析、对比以及反馈，数据驱动，为软件优化和流程改进，提供参考；
>
> Continuous：持续集成环境，即CI环境，包括测试文件提交、扫描编译、执行测试、生成报告及时通知等功能，持续集成是自动化测试的核心！

## 框架对比

### JUnit & TestNG

- 相同点

  都是java测试工具，都是基于注释的且大部分注释相似，它们都可以进行单元测试。

- JUnit和TestNG的不同点

  - 基本注释对比

    | 特点                                 | TestNG                       | JUnit              |
    | ------------------------------------ | ---------------------------- | ------------------ |
    | 测试注释                             | @Test                        | @Test              |
    | 在套件中所有测试用例运行之前         | @BeforeSuit                  | -                  |
    | 在套件中所有测试用例运行之后         | @AfterSuit                   | -                  |
    | 测试运行之前                         | @BeforeTest                  | -                  |
    | 测试运行之前                         | @AfterTest                   | -                  |
    | 在调用任何属于这个组的方法之前运行   | @BeforeGroups                | -                  |
    | 在调用任何属于这个组的方法之后运行   | @AfterGroups                 | -                  |
    | 在调用当前类的第一个测试方法之前运行 | @BeforeClass                 | @BeforeClass       |
    | 在调用当前类的第一个测试方法之后运行 | @AfterClass                  | @AfterClass        |
    | 在每个测试方法之前运行               | @BeforeMethod                | @Before            |
    | 在每个测试方法之后运行               | @AfterMethod                 | @After             |
    | 忽略测试                             | @Test(enable = )        | @ignore            |
    | 预期异常测试                         | @Test(exceptedExceptions = ) | @Test(excepted = ) |
| 超时测试 | @Test(exceptedExceptions = ) |@Test(timeout=)|
    | 监听器 | @Listener |-|
    
    1. 从上述标签可以看出，JUnit能做的，TestNG皆可以。JUnit做不到的，TestNG也能做到。
    
    2. 在JUnit 中，我们必须声明@BeforeClass和@AfterClass方法作为静态方法，TestNG没有这个约束。也就是说，TestNG的@Before* & @After*方法内部不需要是静态成员，也可以调用非静态的成员和函数，大大减少了对于方法的约束，使用自然也就更加方便，应用范围更加广泛。
    3. TestNG的Test标签属性更为丰富，能够实现的功能更多。例如：并行、失败重测等。
    
  - 套件测试
  
    - JUnit
  
      运用“@RunWith”和“@Suite”注释运行套件测试，测试套件运行失败时，JUnit 4会标记为全部失败，之后重新运行整个测试套件。
  
    - TestNG
  
      用XML文件运行套件测试，TestNG不仅可以做捆绑类测试，也可以捆绑方法进行测试。
  
      TestNG测试套件运行失败时，会创建一个XML文件说明失败的测试，利用这个文件执行程序，就不会重复运行已经成功的测试。
      
  
  - 参数化测试
  
    - JUnit
  
      运用“@RunWith”和“@Parameter”注释提供单元测试的参数值，但此方法具有较多限制，比如必须将参数传递给构造函数才能初始化类成员作为测试的参数值。参数类的返回类型为List[]，数据已被限制为String或用于测试的原始类型值。并且在 JUnit 中，如果您想改变某个受测方法的参数组，就只能给每个 不同的参数组编写一个测试用例。
  
    - TestNG
  
      XML文件或“@DataProvider”用于提供不同参数进行测试。当参数类型较复杂时，可使用高级参数化测试，利用TestNG的@DataProvider参数可以处理复杂的参数类型。TestNG相比于JUnit的参数化测试显得更加友好和灵活。

  - 依赖性测试
  
    - JUnit
  
      不支持依赖性测试。
  
    - TestNG
  
      与 JUnit 不同，TestNG 利用 @Test 注释的 dependsOnMethods属性来应对测试的依赖性问题。重要的是，TestNG 如果依赖方法失败，它将被跳过，而不是标记为失败，即跳过而不是标记失败。
      
  
  - 失败和重运行
  
    - JUnit
  
      在 JUnit 4 中，如果测试套件包括 1000 项测试，其中 3 项失败，很可能就需要重新运行整个测试套件（修改错误以后回归测试）。
  
    - TestNG
  
      一旦 TestNG 中出现失败，它就会创建一个 XML 配置文件，对失败的测试加以说明。如果利用这个文件执行 TestNG 运行程序，TestNG 就只 运行失败的测试。当测试套件规模较大时，TestNG在失败和重运行上面的好处就会体现出来。
  
### SOFAActs & TestNG

- SOFAActs

  - 功能描述

    ACTS 提供了以下能力：

    1 一站式编辑

    框架实现了测试数据与测试代码的分离，同时配套提供可视化编辑器 ACTS IDE，通过 ACTS IDE 可以快速地录入、查看和管理用例数据，有效减少重复性编码。

    2 精细化校验

    为了提高返回结果、DB 数据等期望数据的填写效率和减少检验点遗漏，框架提供了预跑返填功能；同时在 ACTS 校验规则标签的标记下，实现期望 DB 数据、期望结果等数据的精细化校验。

    3 灵活可扩展

    ACTS 提供了丰富的 API ，其封装于 ActsRuntimeContext 类中，借助 API 可快速获取和设置自定义参数、用例入参、期望结果等，满足用户对用例数据的自定义操作；

    同时，框架的 ActsTestBase 测试基类对外暴露各个执行阶段方法，包括 prepare，execute，check，clear 等，例如在测试类中通过重写 process 方法可将整个测试脚本重新编排。

    4 统一配置能力

    配置文件中提供丰富的配置能力以定制化框架的个性需求。

   - 应用场景

     基于 SOFABoot 搭建的应用，在 Intellij IDEA 开发环境下快速编写和执行接口测试用例。
  
  - 局限性
  
    1. 缺乏详尽的说明文档。
    2. 缺乏使用示例说明。
    3. 缺乏活跃的社区。

- TestNG

  - 可视化拓展

  - 上手难度
  1. 有详尽的官网文档指导使用。
    2. 有相对活跃的社区环境。
    3. 有成功的实践例子。例如：SOFAActs即是基于TestNG搭建的框架。

